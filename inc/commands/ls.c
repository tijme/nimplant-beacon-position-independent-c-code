/**
 * GNU General Public License, version 2.0.
 *
 * Copyright (c) 2025 Tijme Gommers (@tijme).
 *
 * This source code file is part of C-implant for NimPlant C2. 
 * Licensed under GNU General Public License, version 2.0, and 
 * you are free to use, modify, and distribute this file under 
 * its terms. However, any modified versions of this file must 
 * include this same license and copyright notice.
 */

/**
 * Standard Input Output.
 * 
 * Defines three variable types, several macros, and various functions for performing input and output.
 * https://www.tutorialspoint.com/c_standard_library/stdio_h.htm
 */
#include <stdio.h>

/**
 * Standard Library.
 * 
 * Defines four variable types, several macros, and various functions for performing general functions.
 * https://www.tutorialspoint.com/c_standard_library/stdlib_h.htm
 */
#include <stdlib.h>

/**
 * Booleans.
 * 
 * Defines boolean types.
 * https://pubs.opengroup.org/onlinepubs/007904975/basedefs/stdbool.h.html
 */
#include <stdbool.h>

/**
 * List the files in the current or specified directory.
 * 
 * @note This function was generated by ChatGPT and thus likely not (memory) safe.
 * 
 * @param struct Relocatable* context A struct with all loaded modules & functions.
 * @param struct NimPlantConfig* config A struct with all settings for the current beacon.
 * @param struct NimPlantClient* client A struct with runtime client settings (such as encryption key).
 * @param struct NimPlantTask* lpTask The task that has to be performed and in which the result can be saved.
 * @returns bool Positive if successfully executed.
 */
bool CommandLs(struct Relocatable* context, struct NimPlantConfig* config, struct NimPlantClient* client, struct NimPlantTask* lpTask) {
    BOOL bResultStatus = false;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA findFileData;
    char* lpDirectoryPath = NULL;
    char fullPath[MAX_PATH];

    DEFINE_STRING(lpDot, ".");
    DEFINE_STRING(lpTwoDot, "..");
    DEFINE_STRING(lpNewLine, "\n");
    DEFINE_STRING(lpWildcard, "\\*");

    // If no arguments are provided, list current directory
    if (lpTask->argumentsCount == 0) {
        lpDirectoryPath = lpDot;
    } 
    // If one argument is provided, validate the directory path
    else if (lpTask->argumentsCount == 1) {
        lpDirectoryPath = lpTask->arguments[0];
        
        // Check if the provided path is valid
        if (!context->functions.PathFileExistsA(lpDirectoryPath)) {
            DEFINE_STRING(lpInvalidPath, "[invalid directory path]");
            lpTask->result = context->functions.calloc(context->functions.strlen(lpInvalidPath) + 1, sizeof(char));
            if (lpTask->result == NULL) goto FAILURE_AND_RETURN;
            context->functions.strcpy(lpTask->result, lpInvalidPath);
            bResultStatus = true;
            goto CLEANUP_AND_RETURN;
        }
    } 
    else {
        DEFINE_STRING(lpInvalidArgument, "[invalid argument]");
        lpTask->result = context->functions.calloc(context->functions.strlen(lpInvalidArgument) + 1, sizeof(char));
        if (lpTask->result == NULL) goto FAILURE_AND_RETURN;
        context->functions.strcpy(lpTask->result, lpInvalidArgument);
        bResultStatus = true;
        goto CLEANUP_AND_RETURN;
    }

    // Prepare the search pattern
    context->functions.strcpy(fullPath, lpDirectoryPath);
    context->functions.strcat(fullPath, lpWildcard);

    // Allocate memory for results
    size_t resultSize = 0;
    char* lpResultBuffer = context->functions.calloc(1, sizeof(char));
    if (lpResultBuffer == NULL) goto FAILURE_AND_RETURN;

    // Open directory
    hFind = context->functions.FindFirstFileA(fullPath, &findFileData);
    if (hFind == INVALID_HANDLE_VALUE) goto FAILURE_AND_RETURN;

    // Iterate over directory entries
    do {
        // Skip current (.) and parent (..) directories
        if (context->functions.strcmp(findFileData.cFileName, lpDot) != 0 && context->functions.strcmp(findFileData.cFileName, lpTwoDot) != 0) {
            resultSize += context->functions.strlen(findFileData.cFileName) + 2; // +2 for newline and null terminator
            lpResultBuffer = context->functions.realloc(lpResultBuffer, resultSize);
            if (lpResultBuffer == NULL) goto FAILURE_AND_RETURN;

            context->functions.strcat(lpResultBuffer, findFileData.cFileName);
            context->functions.strcat(lpResultBuffer, lpNewLine);
        }

    } while (context->functions.FindNextFileA(hFind, &findFileData) != 0);

    // Close directory handle
    context->functions.FindClose(hFind);

    // Store result
    lpTask->result = lpResultBuffer;
    bResultStatus = true;

    goto CLEANUP_AND_RETURN;

FAILURE_AND_RETURN:
    if (hFind != INVALID_HANDLE_VALUE) context->functions.FindClose(hFind);
    if (lpResultBuffer != NULL) context->functions.free(lpResultBuffer);
    if (lpTask->result != NULL) context->functions.free(lpTask->result);
    goto CLEANUP_AND_RETURN;

CLEANUP_AND_RETURN:
    goto RETURN;

RETURN:
    return bResultStatus;
}